name: Autocommit Github Changes
author: kassett
description: "This GitHub Action allows you to commit changes to git in a runner."

inputs:
  branch:
    description: "The branch to be committed to, or the base_ref if use-pull-request
      is set to true."
    required: true

  github-token:
    description: "The token that the GH cli tool will use."
    required: true

  use-pull-request:
    description: "If 'true', changes will be committed to a separate branch; a PR
      will subsequently be opened from the PR branch. Defaults to 'false'"
    required: false
    default: "false"

  merge-pull-request:
    description: "Automatically merge the pull request created to the base_ref. Defaults
      to 'false'."
    required: false
    default: "false"

  files:
    description: "A list of files to be committed. If no files are defined, changes
      will be found dynamically. This is a comma-separated list."
    required: false
    default: ""

  commit-untracked-files:
    description: "Whether untracked -- i.e. new files -- should be commit as well.
      Defaults to 'false'."
    required: false
    default: "false"

  commit-message:
    description: "The message that signs commits. Defaults to 'Auto-committing files
      [skip ci]'."
    required: false
    default: "Auto-committed files [skip ci]"

  pull-request-title:
    description: "The title of the PR generated by the action. Defaults to 'Auto-generated
      PR'."
    required: false
    default: "Auto-generated PR"

  pull-request-body:
    description: "The body of the pull request. Defaults to 'Pull request opened by
      Github Actions Bot.'"
    required: false
    default: "Pull request opened by Github Actions Bot."

  delete-branch-after-merge:
    description: "Whether branches should be deleted after merging pull requests.
      Defaults to 'false'."
    required: false
    default: "false"

  pull-request-branch-name:
    description: "The name of the feature branch created when a PR is opened. Defaults
      to a branch name generated from the timestamp."
    required: false
    default: ""

  pull-request-team-reviewers:
    description: "A comma-separated list of teams to be assigned for review when a
      pull request is opened but not merged automatically."
    required: false
    default: ""

  pull-request-user-reviewers:
    description: "A comma-separated list of users to be assigned for review when a
      pull request is opened but not merged automatically."
    required: false
    default: ""


outputs:
  sha:
    description: "The new sha of the commit that was created."
    value: ${{ steps.autocommit_changes.outputs.SHA }}

  branch:
    description: "The name of the new branch created."
    value: ${{ steps.autocommit_changes.outputs.BRANCH }}

runs:
  using: composite
  steps:

  - name: Install actions-toolkit
    run: pip install actions-toolkit
    shell: bash

  - name: Autocommit Changes
    id: autocommit_changes
    env:
      PYTHONUNBUFFERED: 1
      GH_TOKEN: ${{ inputs.github-token }}
      AUTOCOMMIT_CHANGES_BRANCH: ${{ inputs.branch }}
      AUTOCOMMIT_CHANGES_USE_PULL_REQUEST: ${{ inputs.use-pull-request }}
      AUTOCOMMIT_CHANGES_MERGE_PULL_REQUEST: ${{ inputs.merge-pull-request }}
      AUTOCOMMIT_CHANGES_FILES: ${{ inputs.files }}
      AUTOCOMMIT_CHANGES_COMMIT_UNTRACKED_FILES: ${{ inputs.commit-untracked-files
        }}
      AUTOCOMMIT_CHANGES_COMMIT_MESSAGE: ${{ inputs.commit-message }}
      AUTOCOMMIT_CHANGES_PULL_REQUEST_TITLE: ${{ inputs.pull-request-title }}
      AUTOCOMMIT_CHANGES_PULL_REQUEST_BODY: ${{ inputs.pull-request-body }}
      AUTOCOMMIT_CHANGES_DELETE_BRANCH_AFTER_MERGE: ${{ inputs.delete-branch-after-merge
        }}
      AUTOCOMMIT_CHANGES_PULL_REQUEST_BRANCH_NAME: ${{ inputs.pull-request-branch-name
        }}
      AUTOCOMMIT_CHANGES_PULL_REQUEST_USER_REVIEWERS: ${{ inputs.pull-request-user-reviewers
        }}
      AUTOCOMMIT_CHANGES_PULL_REQUEST_TEAM_REVIEWERS: ${{ inputs.pull-request-team-reviewers
        }}
    shell: python
    run: |
      import os
      import json
      import uuid
      import time
      import base64
      import contextlib
      from actions_toolkit import core
      from subprocess import run


      # Environment variables prefixed by AUTOCOMMIT_CHANGES_
      BRANCH = os.getenv("AUTOCOMMIT_CHANGES_BRANCH")
      USE_PULL_REQUEST = os.getenv("AUTOCOMMIT_CHANGES_USE_PULL_REQUEST")
      MERGE_PULL_REQUEST = os.getenv("AUTOCOMMIT_CHANGES_MERGE_PULL_REQUEST")
      FILES = [
          file for file in os.getenv("AUTOCOMMIT_CHANGES_FILES", "").split(",") if file != ""
      ]
      COMMIT_UNTRACKED_FILES = os.getenv("AUTOCOMMIT_CHANGES_COMMIT_UNTRACKED_FILES")
      COMMIT_MESSAGE = os.getenv("AUTOCOMMIT_CHANGES_COMMIT_MESSAGE")
      PULL_REQUEST_TITLE = os.getenv("AUTOCOMMIT_CHANGES_PULL_REQUEST_TITLE")
      PULL_REQUEST_BODY = os.getenv("AUTOCOMMIT_CHANGES_PULL_REQUEST_BODY")
      PULL_REQUEST_BRANCH_NAME = os.getenv("AUTOCOMMIT_CHANGES_PULL_REQUEST_BRANCH_NAME")
      PULL_REQUEST_TEAM_REVIEWERS = [
          x.strip()
          for x in os.getenv("AUTOCOMMIT_CHANGES_PULL_REQUEST_TEAM_REVIEWERS").split(",") if x.strip() != ""
      ]
      PULL_REQUEST_USER_REVIEWERS = [
          x.strip()
          for x in os.getenv("AUTOCOMMIT_CHANGES_PULL_REQUEST_USER_REVIEWERS").split(",") if x.strip() != ""
      ]
      DELETE_BRANCH_AFTER_MERGE = os.getenv("AUTOCOMMIT_CHANGES_DELETE_BRANCH_AFTER_MERGE")
      GIT_ROOT = (
          run(args="git rev-parse --show-toplevel", shell=True, capture_output=True, check=True)
          .stdout.decode("utf-8")
          .strip()
      )


      def run_git_command(command: str) -> list[str]:
          output = run(
              args=f"git {command}", shell=True, capture_output=True, check=True, cwd=GIT_ROOT
          )
          return [x for x in output.stdout.decode("utf-8").strip().split("\n") if x != ""]


      def run_gh_command(
          path: str,
          form_arguments: dict | None = None,
          is_delete: bool = False,
          is_put: bool = False,
          check_for_latest: bool = True,
      ) -> dict | None:
          if check_for_latest:
              LatestSHA.handle_changed_remote()

          path = f"/repos/:owner/:repo/{path}"
          command = "gh api"
          if form_arguments is not None:
              command += " -X POST" if not is_put else " -X PUT"
          elif is_delete:
              command += " -X DELETE"

          command += f" {path}"

          if form_arguments is not None:
              temporary_path = os.path.join("/tmp", f"{uuid.uuid4()!s}.json")
              with open(temporary_path, "w", encoding="utf-8") as f:
                  json.dump(form_arguments, f, ensure_ascii=False, indent=4)
              command += f" --input {temporary_path}"

          output = run(args=command, shell=True, capture_output=True, check=True, cwd=GIT_ROOT)
          if output.stdout is not None and output.stdout.decode("utf-8").strip() != "":
              return json.loads(output.stdout.decode("utf-8").strip())


      def refresh_environment():
          # If this fails, there was sure to be a merge conflict anyway

          local_changes = False
          if len(run_git_command("diff --name-only")) > 0:
              local_changes = True

          run_git_command("fetch")

          if local_changes:
              run_git_command("stash")
          run_git_command("config pull.rebase false")
          run_git_command(f"pull")

          if local_changes:
              run_git_command("stash pop")


      def export_new_commit(sha: str):
          with contextlib.suppress(KeyError, FileNotFoundError):
              with open(os.environ["GITHUB_OUTPUT"], "a") as fh:
                  print(f"SHA={sha}", file=fh)


      def export_new_branch(branch: str):
          with contextlib.suppress(KeyError, FileNotFoundError):
              with open(os.environ["GITHUB_OUTPUT"], "a") as fh:
                  print(f"BRANCH={branch}", file=fh)


      class LatestSHA:
          latest_sha: str = ""

          @classmethod
          def init(cls):
              cls.latest_sha = run_gh_command(f"commits/{BRANCH}", check_for_latest=False)[
                  "sha"
              ]

          @classmethod
          def handle_changed_remote(cls):
              new_sha = run_gh_command(f"commits/{BRANCH}", check_for_latest=False)["sha"]
              if new_sha != cls.latest_sha:
                  core.info("Restarting commit process as a new ref was found.")
                  run_commit_process()
                  exit(0)


      class ChangedFile:
          def __init__(self, path: str):
              self.path = path
              self.encoding = "utf-8"
              self.blob_sha = None
              self.is_delete = False

              # Read the file in binary mode and encode to Base64
              try:
                  with open(os.path.join(GIT_ROOT, self.path), "rb") as f:
                      self.content = base64.b64encode(f.read()).decode("utf-8")
              except FileNotFoundError:
                  self.is_delete = True

              if not self.is_delete:
                  self.create_blob()

          def create_blob(self):
              core.info(f"Commit blob of file {self.path}")
              response = run_gh_command(
                  "git/blobs", {"encoding": "base64", "content": self.content}
              )
              self.blob_sha = response["sha"]

          def as_dict(self):
              return {
                  "path": self.path,
                  "mode": "100644",
                  "type": "blob",
                  "sha": self.blob_sha if not self.is_delete else None,
              }


      def find_files() -> list[str]:
          files = [f for f in run_git_command(f"diff --name-only") if f != ""]
          if COMMIT_UNTRACKED_FILES == "true":
              files.extend(
                  [
                      f
                      for f in run_git_command("ls-files --others --exclude-standard")
                      if f != ""
                  ]
              )
          return files


      def diverged_from_remote(path: str) -> bool:
          # Will return whether a file has changed from the remote branch
          output = run_git_command(f"diff {LatestSHA.latest_sha} -- {path}")
          return len(output) != 0


      def create_new_branch():
          new_branch = (
              f"{BRANCH}-autocommit-{int(time.time())}"
              if PULL_REQUEST_BRANCH_NAME == ""
              else PULL_REQUEST_BRANCH_NAME
          )
          run_gh_command(
              "git/refs", {"ref": f"refs/heads/{new_branch}", "sha": LatestSHA.latest_sha}
          )
          return new_branch


      def get_tree_tip():
          output = run_gh_command(f"git/trees/{LatestSHA.latest_sha}")
          return output["sha"]


      def create_new_tree(base_tree: str, changed_files: list[ChangedFile]) -> str:
          arguments = {
              "base_tree": base_tree,
              "tree": [c.as_dict() for c in changed_files],
          }
          output = run_gh_command("git/trees", arguments)
          return output["sha"]


      def commit_the_tree(tree: str) -> str:
          arguments = {
              "parents": [LatestSHA.latest_sha],
              "tree": tree,
              "message": COMMIT_MESSAGE,
          }
          output = run_gh_command("git/commits", arguments, check_for_latest=False)

          new_commit = output["sha"]
          return new_commit


      def update_branch(branch: str, commit: str):
          run_gh_command(f"git/refs/heads/{branch}", {"sha": commit})


      def open_pull_request(origin_branch: str, feature_branch: str):
          return run_gh_command(
              "pulls",
              {
                  "head": feature_branch,
                  "base": origin_branch,
                  "title": PULL_REQUEST_TITLE,
                  "body": PULL_REQUEST_BODY,
              },
              check_for_latest=False,
          )["number"]


      def merge_pull_request(pr_number: int):
          run_gh_command(
              f"pulls/{pr_number}/merge",
              {"commit_title": PULL_REQUEST_TITLE, "commit_message": COMMIT_MESSAGE},
              is_put=True,
              check_for_latest=False,
          )


      def run_commit_process():
          core.info(f"Pulling the latest version of {BRANCH}")

          refresh_environment()
          LatestSHA.init()

          core.info(f"Working off the latest commit to branch {BRANCH}: {LatestSHA.latest_sha}")

          files_changed = (
              [f for f in FILES if diverged_from_remote(f)] if len(FILES) > 0 else find_files()
          )
          if len(files_changed) == 0:
              core.info(f"No files have been changed since {LatestSHA.latest_sha}")
              exit(0)

          files_changed = [ChangedFile(f) for f in files_changed]
          core.info(f"{len(files_changed)} file changes since {LatestSHA.latest_sha}")

          working_branch = BRANCH
          if USE_PULL_REQUEST == "true":
              working_branch = create_new_branch()
              export_new_branch(working_branch)
              core.info(f"Committing changes to branch {working_branch}")

          working_tree = get_tree_tip()
          core.info(f"Making changes to tree {working_tree}")

          new_tree = create_new_tree(working_tree, files_changed)
          core.info(f"Updated tree is {new_tree}")

          new_commit = commit_the_tree(new_tree)
          core.info(f"Newest commit is {new_commit}")

          export_new_commit(new_commit)

          update_branch(working_branch, new_commit)
          core.info(f"Remote ref updated")

          if working_branch != BRANCH:
              pr_number = open_pull_request(BRANCH, working_branch)
              core.info(f"Pull request opened to {BRANCH}")
              if MERGE_PULL_REQUEST == "true":
                  merge_pull_request(pr_number)
                  core.info(f"Pull request to {BRANCH} merged")
                  if DELETE_BRANCH_AFTER_MERGE == "true":
                      run_gh_command(
                          f"git/refs/heads/{working_branch}",
                          is_delete=True,
                          check_for_latest=False,
                      )
                      core.info(f"Temporary branch {working_branch} deleted.")
              elif PULL_REQUEST_TEAM_REVIEWERS != "" or PULL_REQUEST_USER_REVIEWERS != "":
                  params = {}
                  if PULL_REQUEST_USER_REVIEWERS != "":
                      params["reviewers"] = PULL_REQUEST_USER_REVIEWERS
                  if PULL_REQUEST_TEAM_REVIEWERS != "":
                      params["team_reviewers"] = PULL_REQUEST_TEAM_REVIEWERS
                  run_gh_command(
                      f"pulls/{pr_number}/requested_reviewers",
                      params,
                      check_for_latest=False,
                  )
                  core.info("Assigned reviewers for the pull request.")


      if __name__ == "__main__":
          run_commit_process()
