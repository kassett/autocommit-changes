name: Autocommit Github Changes
author: kassett
description: "This GitHub Action allows you to commit changes to git in a runner."

inputs:
  branch:
    description: "The branch to be committed to, or the base_ref if use-pull-request
      is set to true."
    required: true

  github-token:
    description: "The token that the GH cli tool will use."
    required: true

  use-pull-request:
    description: "If 'true', changes will be committed to a separate branch; a PR
      will subsequently be opened from the PR branch. Defaults to 'false'"
    required: false
    default: "false"

  merge-pull-request:
    description: "Automatically merge the pull request created to the base_ref. Defaults
      to 'false'."
    required: false
    default: "false"

  files:
    description: "A list of files to be committed. If no files are defined, changes
      will be found dynamically. This is a comma-separated list."
    required: false
    default: ""

  commit-untracked-files:
    description: "Whether untracked -- i.e. new files -- should be commit as well.
      Defaults to 'false'."
    required: false
    default: "false"

  commit-message:
    description: "The message that signs commits. Defaults to 'Auto-committing files
      [skip ci]'."
    required: false
    default: "Auto-committed files [skip ci]"

  pull-request-title:
    description: "The title of the PR generated by the action. Defaults to 'Auto-generated
      PR'."
    required: false
    default: "Auto-generated PR"

  pull-request-body:
    description: "The body of the pull request. Defaults to 'Pull request opened by
      Github Actions Bot.'"
    required: false
    default: "Pull request opened by Github Actions Bot."

  delete-branch-after-merge:
    description: "Whether branches should be deleted after merging pull requests.
      Defaults to 'false'."
    required: false
    default: "false"

outputs:
  sha:
    description: "The new sha of the commit that was created."
    value: ${{ steps.autocommit_changes.outputs.SHA }}

runs:
  using: composite
  steps:

  - name: Checkout code
    uses: actions/checkout@v4
    with:
      fetch-depth: 0
      ref: ${{ inputs.branch }}

  - name: Debugging with tmate
    uses: mxschmitt/action-tmate@v3.18

  - name: Autocommit Changes
    id: autocommit_changes
    env:
      GH_TOKEN: ${{ inputs.github-token }}
      AUTOCOMMIT_CHANGES_BRANCH: ${{ inputs.branch }}
      AUTOCOMMIT_CHANGES_USE_PULL_REQUEST: ${{ inputs.use-pull-request }}
      AUTOCOMMIT_CHANGES_MERGE_PULL_REQUEST: ${{ inputs.merge-pull-request }}
      AUTOCOMMIT_CHANGES_FILES: ${{ inputs.files }}
      AUTOCOMMIT_CHANGES_COMMIT_UNTRACKED_FILES: ${{ inputs.commit-untracked-files
        }}
      AUTOCOMMIT_CHANGES_COMMIT_MESSAGE: ${{ inputs.commit-message }}
      AUTOCOMMIT_CHANGES_PULL_REQUEST_TITLE: ${{ inputs.pull-request-title }}
      AUTOCOMMIT_CHANGES_PULL_REQUEST_BODY: ${{ inputs.pull-request-body }}
      AUTOCOMMIT_CHANGES_DELETE_BRANCH_AFTER_MERGE: ${{ inputs.delete-branch-after-merge
        }}
    shell: python
    run: |
      import os
      import json
      import uuid
      import time
      import base64
      import contextlib
      from subprocess import run


      # Environment variables prefixed by AUTOCOMMIT_CHANGES_
      BRANCH = os.getenv("AUTOCOMMIT_CHANGES_BRANCH")
      USE_PULL_REQUEST = os.getenv("AUTOCOMMIT_CHANGES_USE_PULL_REQUEST")
      MERGE_PULL_REQUEST = os.getenv("AUTOCOMMIT_CHANGES_MERGE_PULL_REQUEST")
      FILES = [
          file for file in os.getenv("AUTOCOMMIT_CHANGES_FILES", "").split(",") if file != ""
      ]
      COMMIT_UNTRACKED_FILES = os.getenv("AUTOCOMMIT_CHANGES_COMMIT_UNTRACKED_FILES")
      COMMIT_MESSAGE = os.getenv("AUTOCOMMIT_CHANGES_COMMIT_MESSAGE")
      PULL_REQUEST_TITLE = os.getenv("AUTOCOMMIT_CHANGES_PULL_REQUEST_TITLE")
      PULL_REQUEST_BODY = os.getenv("AUTOCOMMIT_CHANGES_PULL_REQUEST_BODY")
      DELETE_BRANCH_AFTER_MERGE = os.getenv("AUTOCOMMIT_CHANGES_DELETE_BRANCH_AFTER_MERGE")
      GIT_ROOT = (
          run(args="git rev-parse --show-toplevel", shell=True, capture_output=True, check=True)
          .stdout.decode("utf-8")
          .strip()
      )


      def run_git_command(command: str) -> list[str]:
          output = run(
              args=f"git {command}", shell=True, capture_output=True, check=True, cwd=GIT_ROOT
          )
          return [x for x in output.stdout.decode("utf-8").strip().split("\n") if x != ""]


      def run_gh_command(
              path: str,
              form_arguments: dict | None = None,
              is_delete: bool = False,
              is_put: bool = False,
              check_for_latest: bool = True
      ) -> dict | None:

          if check_for_latest:
              LatestSHA.handle_changed_remote()

          path = f"/repos/:owner/:repo/{path}"
          command = "gh api"
          if form_arguments is not None:
              command += " -X POST" if not is_put else " -X PUT"
          elif is_delete:
              command += " -X DELETE"

          command += f" {path}"

          if any(isinstance(v, (dict, list)) for v in (form_arguments or {}).values()):
              temporary_path = os.path.join("/tmp", f"{uuid.uuid4()!s}.json")
              with open(temporary_path, "w", encoding="utf-8") as f:
                  json.dump(form_arguments, f, ensure_ascii=False, indent=4)
              command += f" --input {temporary_path}"
          else:
              for k, v in (form_arguments or {}).items():
                  command += f" -f {k}='{v}'"

          output = run(args=command, shell=True, capture_output=True, check=True, cwd=GIT_ROOT)
          if output.stdout is not None and output.stdout.decode("utf-8").strip() != "":
              return json.loads(output.stdout.decode("utf-8").strip())


      def refresh_environment():
          # If this fails, there was sure to be a merge conflict anyway
          run_git_command("fetch")
          run_git_command("stash")
          run_git_command("config pull.rebase false")
          run_git_command(f"pull")
          run_git_command("stash pop")


      def export_new_commit(sha: str):
          with contextlib.suppress(KeyError, FileNotFoundError):
              with open(os.environ["GITHUB_OUTPUT"], "a") as fh:
                  print(f"SHA={sha}", file=fh)


      class LatestSHA:
          latest_sha: str = ""

          @classmethod
          def init(cls):
              cls.latest_sha = run_gh_command(f"commits/{BRANCH}", check_for_latest=False)["sha"]

          @classmethod
          def handle_changed_remote(cls):
              new_sha = run_gh_command(f"commits/{BRANCH}", check_for_latest=False)["sha"]
              if new_sha != cls.latest_sha:
                  run_commit_process()
                  exit(0)


      class ChangedFile:
          def __init__(self, path: str):
              self.path = path
              self.encoding = "utf-8"
              self.blob_sha = None
              self.is_delete = False

              # Read the file in binary mode and encode to Base64
              try:
                  with open(os.path.join(GIT_ROOT, self.path), "rb") as f:
                      self.content = base64.b64encode(f.read()).decode("utf-8")
              except FileNotFoundError:
                  self.is_delete = True

              if not self.is_delete:
                  self.create_blob()

          def create_blob(self):
              response = run_gh_command(
                  "git/blobs", {"encoding": "base64", "content": self.content}
              )
              self.blob_sha = response["sha"]

          def as_dict(self):
              return {
                  "path": self.path,
                  "mode": "100644",
                  "type": "blob",
                  "sha": self.blob_sha if not self.is_delete else None,
              }


      def find_files() -> list[str]:
          files = [
              f for f in run_git_command(f"diff --name-only") if f != ""
          ]
          if COMMIT_UNTRACKED_FILES == "true":
              files.extend(
                  [
                      f
                      for f in run_git_command("ls-files --others --exclude-standard")
                      if f != ""
                  ]
              )
          return files


      def diverged_from_remote(path: str) -> bool:
          # Will return whether a file has changed from the remote branch
          output = run_git_command(f"diff {LatestSHA.latest_sha} -- {path}")
          return len(output) != 0


      def create_new_branch():
          new_branch = f"{BRANCH}-autocommit-{int(time.time())}"
          run_gh_command(
              "git/refs", {"ref": f"refs/heads/{new_branch}", "sha": LatestSHA.latest_sha}
          )
          return new_branch


      def get_tree_tip():
          output = run_gh_command(f"git/trees/{LatestSHA.latest_sha}")
          return output["sha"]


      def create_new_tree(base_tree: str, changed_files: list[ChangedFile]) -> str:
          arguments = {
              "base_tree": base_tree,
              "tree": [c.as_dict() for c in changed_files],
          }
          output = run_gh_command("git/trees", arguments)
          return output["sha"]


      def commit_the_tree(tree: str) -> str:
          arguments = {
              "parents": [LatestSHA.latest_sha],
              "tree": tree,
              "message": COMMIT_MESSAGE,
          }
          output = run_gh_command("git/commits", arguments, check_for_latest=False)

          new_commit = output["sha"]
          return new_commit


      def update_branch(branch: str, commit: str):
          run_gh_command(f"git/refs/heads/{branch}", {"sha": commit})


      def open_pull_request(origin_branch: str, feature_branch: str):
          return run_gh_command(
              "pulls",
              {
                  "head": feature_branch,
                  "base": origin_branch,
                  "title": PULL_REQUEST_TITLE,
                  "body": PULL_REQUEST_BODY,
              },
              check_for_latest=False
          )["number"]


      def merge_pull_request(pr_number: int):
          run_gh_command(
              f"pulls/{pr_number}/merge",
              {"commit_title": PULL_REQUEST_TITLE, "commit_message": COMMIT_MESSAGE},
              is_put=True,
              check_for_latest=False
          )


      def run_commit_process():
          refresh_environment()
          LatestSHA.init()

          files_changed = [f for f in FILES if diverged_from_remote(f)] if len(FILES) > 0 else find_files()
          if len(files_changed) == 0:
              exit(0)

          files_changed = [ChangedFile(f) for f in files_changed]

          working_branch = BRANCH
          if USE_PULL_REQUEST == "true":
              working_branch = create_new_branch()

          working_tree = get_tree_tip()
          new_tree = create_new_tree(working_tree, files_changed)
          new_commit = commit_the_tree(new_tree)
          export_new_commit(new_commit)
          update_branch(working_branch, new_commit)

          if working_branch != BRANCH:
              pr_number = open_pull_request(BRANCH, working_branch)
              if MERGE_PULL_REQUEST == "true":
                  merge_pull_request(pr_number)
                  if DELETE_BRANCH_AFTER_MERGE == "true":
                      run_gh_command(f"git/refs/heads/{working_branch}", is_delete=True, check_for_latest=False)


      if __name__ == "__main__":
          run_commit_process()
